/*=====================================
  ■■■ 클래스 고급 ■■■
  - 상속(Inheritance)
=====================================*/

/*
※ 『super』

	static으로 선언되지 않은 메소드에서 사용되며
	(static은 클래스가 로딩될 때 동시에 메모리 퍼올려지므로 인스턴스와 전혀 상관ㄴㄴ)
	현재 클래스가 상속받은 상위 클래스의 객체를 가리킨다.
	super는 상위 클래스의 생성자를 호출하거나
	상위 클래스의 멤버 변수 또는 메소드를 호출할 때 사용할 수 있다.

	하위 클래스의 생성자에서 상위 클래스의 생성자를 호출할 때에는
	하위 클래스의 생성자 정의 구문에서 맨 처음에만 위치할 수 있다.

	클래스 자체가 아니라.. 객체(그 클래스의 주소??)를 가리키는 것.

※ 생성자와 클래스 상속 간의 관계

	하위 클래스는 상위 클래스의 멤버를 상속받지만,
	생성자는 상속 대상에서 제외된다.
	그리고, 하위 클래스의 생성자가 호출될 때(하위 클래스의 인스턴스를 호출 할 때)
	자동으로 상위 클래스의 생성자가 호출된다. // super();
	이 때, 상위 클래스의 생성자는 인수가 없는 생성자(default 생성자 형태)가 호출된다.

	상위 클래스 및 사위 클래스를 설계하는 과정에서
	생성자를 정의하지(작성하지) 않거나 인스가 없는 생성자만을 정의한(작성한) 경우
	명시적으로 하위 글래스에서 상위 클래스의 생성자를 호출하지 않아도
	아무런 문제가 발생하지 않지만
	상위 클래스에 인자가 있는 생성자만 존재하는 경우에는 주의해야 한다.

	예를 들어 다음에서...

	class A_class
	{	
		A_class(int n)
		{
		}
	}

	class B_class extends A_class
	{
		B_class()
		{
			// super(10); 상위 클래스에 인수가 있으면 얜 무의미
			...;
			...;
		}
	}

	==================================================================================================
	상위 클래스					| 하위 클래스					| 결과
	==================================================================================================
	생성자를					| 생성자 정의 안함				| → 가능하다.
	정의하지					| 인수가 없는 생성자			| → 가능하다.
	않음						| 인수가 있는 생성자			| → 가능하다.
	---------------------------------------------------------------------------------------------------
	인수가						| 생성자 정의 안함				| → 가능하다.
	없는						| 인수가 없는 생성자			| → 가능하다.
	생성자만 정의				| 인수가 있는 생성자			| → 가능하다.
	-------------------------------------------------------------------------------------------------
	인수가						| 생성자 정의 안함				| → 에러 발생~!!!						
	있는						| 인수가 없는 생성자			| → 상위 클래스의 해당 생성자를 호출(b(int 어쩌구))하지 않으면 에러 발생~!!!	
	생성자만 정의				| 인수가 있는 생성자			| → 상위 클래스의 해당 생성자를 호출(b(int 어쩌구))하지 않으면 에러 발생~!!!	
	===================================================================================================

	하위 클래스인 B_class의 생성자에서
	명시적으로 A_class의 생성자를 호출하지 않으면
	자동적으로 인자가 없는 생성자를 호출한다.
	하지만, A_class에는 인자가 있는 생성자만 존재하고 
	인자가 없는 생성자는 존재하지 않기 때문에 에러가 발생한다.
	따라서, B_class 생성자 선두에
	다음처럼 명시적으로 상위 클래스의 생성자를 호출해야 한다.

	※ 상속 시 주의할 사항
	
	   상위 클래스에서 선언된 멤버 변수의 이름과
	   하위 클래스에서 선언한 멤버 변수의 이름이 같으면
	   상위 클래스의 멤보 변수는 무시된다. // 무시되는 거지 없어지는 게 아님
	   이 때, 상위 클래스의 멤버 변수를 사용하기 위해서는
	   『super』 키워드를 사용한다.

	   동일한 이름의 멤버 변수나 동일한 이름의 메소드가
	   한 클래스 안에 선언되어 있거나 정의되는 경우 기본적으로 에러 발생한다.
	   단, 메소드의 경우에는 매개변수의 개수나 타입이 다른 경우
	   에러가 발생하지 않고 다른 메소드로 취급하게 된다.(Method Overloading)
	   → Method Overriding 과 구분하여 개념을 정리해 둘 것~!!!

*/

// 부모가 여러인 게 다중상속(자바는 허용 안해줌)

// 부모 클래스 
class SuperTest107
{
	protected double area;
	private String title;

	public SuperTest107()	// 생성자. 리턴 자료 없고 클래스 이름과 같고.
	{
		System.out.println("SuperTest107... 인자 없는 생성자");
	}

	public SuperTest107(String title)	// 사용자 정의 생성자. 문자열 매개변수.
	{
		this.title = title;
		System.out.println("SuperTest107... 문자열을 인자로 받는 생성자");
	}

	public void write()
	{
		System.out.println(title + " - " + area);
	}
}


// SuperTest107을 상속받는 자식 클래스

class Rect extends SuperTest107
{
	/*
	얘가 생속 받는 것
	protected double area; 상속 ○
	public void write()
	{
		System.out.println(title + " - " + area); 상속 ○
	}


	(private은 '나만 보는 거'라 상속 X
	생성자들은 상속 X
	*/

	Rect()
	{
		super();
	}
	
	private int w,h;	// 자식 클래스에 있다고 부모 클래스가 마구 가져다 쓸 수 X

	public void calc(int w, int h)
	{
		this.w = w;			// rect의 w, h
		this.h = h;
		area = (double)this.w * this.h;
		//super.area = (double)this.w * this.h; 와 같은 구문!
		write();
		// 물려받은 write도 있고, 내 write도 있다!
		// 내 write를 쓴다!
		/*
				public void write()
		{
			내용물 수정;
		}
		부모님한테 물려받는 차 내부를 내가 원하는대로 '튜닝'해서 쓰는 것.
		이것이 오버라이딩의 개념~!
		변수는 내 차 따로/부모 차 따로인데
		메소드는 물려받은 차를 재구성해서 씀
		위의 경우 부모로부터 물려받은 write에 내 write를 덮어쓰기 한다는 것.
		즉 메소드를 '재정의'
		*/
	}

	@Override	// metadata → 어노테이션(Annotation) JDK 1.5부터.. 
	// 기능은 따로 안하지만 어떤 기능인지 알려주는 것.(ex 해시태그)
	// 내가 일부러 오버라이드 하고 있음을 사람들과 자바에게 알려주기 위해.
	// 구글은 메타데이터를 굉장히 잘 활용한 사례

	public void write()	
	{
		System.out.println("w : " + w + ", h : " + h);	// 여기서 보여지는 w는 하나 뿐이라. this 붙여도 되고 안붙여도 됨.
		System.out.println("사각형 → " + area); // this.area, super.area 다 됨.
	}
	// ※ 메소드 오버라이딩(Method Overriding)
	//	  상위 클래스를 상속받은 하위 클래스에서
	//	  상위 클래스에 정의된 메소드를 재.정.의. 하는 것으로
	//    객체 지향 프로그래밍의 특징인 다형성을 나타낸다.
	//	  재정의(Overriding)는 반드시 상속 관계까 있어야 하며,
	//	  메소드, 이름, 리턴 타입, 매개변수의 개수나 타입이
	//	  모두 완전히 일치해야 한다. 

}

// SuperTest107을 상속받는 자식 클래스
class Circle extends SuperTest107
{
	/*
	얘가 생속 받는 것
	protected double area; 상속 ○
	public void write()
	{
		System.out.println(title + " - " + area); 상속 ○
	}


	(private은 '나만 보는 거'라 상속 X
	생성자들은 상속 X
	*/


	Circle(String title)
	{
		super(title);
	}
	
	public void calc(int r)		
	{
		area = r * r * 3.141592; 
		write();
	}
// Rect의 area와 Circle의 area는 공유되지 않는다. 서로의 area가 안보임.
// 부모가 같다고 자식들끼리 형제인 건 아님.
// 즉 write도 Circle이 개조한 게 아니라 부모 걸 받아옴.
}

// main() 메소드를 포함하고 있는 외부의 다른 클래스 
public class Test107 extends SuperTest107
{
	public static void main(String[] args)
	{
		Rect ob1 = new Rect();
		//--==>> superTest107... 인자 없는 생성자
		// Rect 안에 ()super;가 없어도 에러 안남!!! 자동으로 부모 인스턴스 호출하니까~! 디폴트처럼..

		// Circle ob2 = new Circle(); 
		//--==>> 에러 발생(컴파일 에러) Circle엔 이렇게 생긴 것 없음.
		//-- Circle 클래스의 매개변수가 존재하는 사용자 정의 생성자로 인해
		//   default 생성자가 삽입되지 않음.
		//	 → 매개변수가 없는 생성자가 존재하지 않아 발생하게 되는 에러
		
		Circle ob3 = new Circle("원");
		//--==>> SuperTest107... 문자열을 인자로 받는 생성자
		// 문자열 받는 부모생성자의 title을 초기화
		// private이지만 메소드를 이용하면 가능! 즉 외부에서
		// private String title;로 접근한게 아니라
		// public SupterTest107(String title)로 접근한 것!!

		ob1.calc(10, 5);
		//--==>> w : 10, h : 5
		//		사각형 → 50.0

		ob3.calc(50);
		//--==>> 원 - 7853.9800000000005


		/* 실행 결과
		SuperTest107... 인자 없는 생성자
		SuperTest107... 문자열을 인자로 받는 생성자
		w : 10, h : 5
		사각형 → 50.0
		원 → 7853.9800000000005
		*/

	}
}

// 질문 오버라이딩, 오버로딩 할 때 접근제어지시자는 같게 써야하나?
// 접근제어지시자를 변경할 때는 원래 가지고 있는 것보다 크게 변경하는 건 가능./
// But 줄이는 건 안돼!!!