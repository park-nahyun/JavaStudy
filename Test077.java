/*=====================================
  ■■■ 클래스와 인스턴스 ■■■
  - 생성자(Constructor)
=====================================*/

public class Test077
{
	int x;

	// ※ 생성자의 이름은 항상 예외없이 클래스의 이름과 동일해야 한다.
	//	   필요한 경우 인수를 받아들이는 것도 가능하고,
	//	   같은 이름의 메소드를 정의하는 중복 정의가 가능하지만
	//     리턴 값(반환 값)은 가질 수 없다.

	// ※ 생성자는 다른 일반 메소드들처럼 호출될 수 없고,
	//    『new』 연산자를 이용하여 객체를 생성하기 위해 호출되며,
	//     각 클래스의 인스턴스인 객체를 생성한 후에
	//     생성된 객체의 멤버를 초기화시키는 작업을 수행한다.



	Test077() // 생성자
	{
		this(9);
		// ※ 생성자 내부에서 다른 생성자를 호출하는 것은 가능하다.
		//	  단,   ① 호출 방법에는 일반적인 메소드의 호출 구문과 차이를 보인다.
		//    또한, ② 생성자 내부에서 가장 먼저 실행(호출)되어야 한다.
		//          ＊ 『this』를 써야함 
		//				일반적인 메소드 호출은 이름을 부르는 거지만.. 생성자는 이름을 못부름
		//				생성자 이름은 클래스와 동일하지? 그런데 클래스 이름을 부르는게 이미 선점 당함..

		x = 10;
		System.out.println("생성자 호출 - 인자가 없는 생성자");
	}

	Test077(int x) // 생성자
	{
		// ★ x = x; // 넘겨받은 매개변수 100을 x로 초기화 하고 싶다..는 건데..
						// 에러는 안나지만, 100 초기화 안되고 있음.

		// Test077.x = x;
		// 좌쪽은 Test077의 x고 우측은 넘겨받은 매개 변수 x다.. 라고 하면 좋겠지만
		// 이미 클래스.어쩌구는 선점 당함..^^
		// 그래서 this를 쓰는 것..
	
		this.x = x;
		// x가 포함된 클래스로 this가 치환된다!!
		
		System.out.println("생성자 호출 - 인자가 하나인 생성자");
	}

	public static void main(String[] args)
	{
		// Test077 클래스 기반의 인스턴스 생성
		Test077 ob1 = new Test077();
		Test077 ob2 = new Test077(100);
		// ※ 생성자는 『new』 연산자를 이용하여 객체를 생성하기 위해 호출되며
		//    클래스 객체에 대한 인스턴스가 생성되면
		//	  이 객체는 비로소 메모리를 할당받게 된다.

		System.out.println("main 에서 ob1.x : " + ob1.x);
		System.out.println("main 에서 ob2.x : " + ob2.x);

		//--==>> main 에서 ob1.x : 10
		//--==>> main 에서 ob2.x : 0
	}
} 

/*
public class 과일장수
{
	int x; (★)

	메소드1()
	{
		x = 10;
	}

	메소드2(int x) (☆)
	{
		x = x;

		x= 100; 일 때는 좌변의 x가  ★을 뜻함.
		그런데 x = x;라고 하면 좌변의 x가 ☆를 뜻하게 됨..
		메소드 안정성 때문에..

		(메소드2) 스코프에 int x가 두 번 보이면 헷갈리겠지?
		원래는 보이는 영역에서 똑같이 쓸 수 없지만.. 

		과일장수를 생각해보면..
		int a1;
		int b1;..
		등 속성이 되게 여러가지 일 것

		생성자(int x, int y2, int x5)
		{
			a1 = x1
			b1 = y1..

			이렇게 하면 문자가 많아서 넘 헷갈리지?
			그래서 a1은 a1에 담아~ 하고 생성자가 같은 변수 쓰게 허가해준 것..


			그러면 x = x;는 어떻게 처리?
			그래서 등장한 것이 『this』..!
			클래스 영역 안에서 this를 쓰면
			this가 포함되어 있는 클래스 이름으로 치환하면 된다!

			『this』 → 『과일장수』
		}

	}
}



*/

/* 생성자에서 다른 생성자를 호출하는 것이 가능할까?
가능한!! But 방식이 까다롭다! 전제조건이 있다!

메소드 안에서 다른 메소드 호출하는 것이 가능하지???
생성자 안에서 다른 생성자 호출하려면 생성자 내부에서 ★제일 먼저! 실행 될 수 있도록 해야한다!

*/

/*
생성자 호출 - 인자가 하나인 생성자
생성자 호출 - 인자가 없는 생성자
생성자 호출 - 인자가 하나인 생성자
main 에서 ob1.x : 10
main 에서 ob2.x : 100
계속하려면 아무 키나 누르십시오 . . .
*/